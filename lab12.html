<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="UTF-8">
    <title>Fast Robots Wiki</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="robot-car-icon.jpg">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
</head>

<body>
    <section class="page-header">
        <button class="back">Home</button>
        <h1 class="project-name">Fast Robots</h1>
        <h2 class="project-tagline">Joseph Horwitz's Wiki for ECE 4960 Fast Robots Course</h2>
        <a target="_blank" href="https://github.com/joeyhz/Fast-Robots" class="btn">View on GitHub</a>
    </section>
    <section class="main-content">
        <h2>Lab 12 - Localization on Robot</h2>

        <p>
            In this lab I ran a limited Bayes Filter localization on the physical robot. At this point the robot is still not moving by itself around the map. Instead, I placed the robot in four marked locations on the map, had it take measurements while rotating,
            and ran the update step of the Bayes filter to estimate position based off of sensor data.
        </p>
        <h3>Simulated Localization:</h3>
        <p>
            Before attempting localization on the robot, I ran the Bayes filter provided by course staff on the FlatLand simulator in order to assure there are no issues. Below is the plotter output from that run:
        </p>
        <h4>Simulated Localization Plot (Red: odometry, Green: ground truth, Blue: belief)</h4>
        <img width="500" src="lab content/lab 12 content/sim_plot.png">

        <h3>Observation Loop:</h3>
        <p>
            I used the same observation loop as in Lab 9, but adjusted the PID controller so that it would turn 20 degrees per observation rather than 24 degrees. Then I could collect 18 independent TOF observations instead of 15 readings like in Lab 9. The Python
            code used to collect and process the observation data is below:
        </p>

        <h4>Code to Perform Observation Loop</h4>
        <!-- HTML generated using hilite.me -->
        <div style="background: #ffffff; overflow:auto;width:auto;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">def</span> <span style="color: #0066BB; font-weight: bold">perform_observation_loop</span>(<span style="color: #007020">self</span>, rot_vel<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">120</span>):
        <span style="color: #888888"># Initialize my custom robot controller class</span>
        rc <span style="color: #333333">=</span> RobotControl(ble)

        <span style="color: #888888"># Spin in place with PWM = 95, collecting sensor data</span>
        rc<span style="color: #333333">.</span>spin_360(<span style="color: #0000DD; font-weight: bold">95</span>)

        <span style="color: #888888"># We need to explicitly stop recording data after it stops spinning</span>
        <span style="color: #008800; font-weight: bold">while</span> rc<span style="color: #333333">.</span>sensor_readings <span style="color: #000000; font-weight: bold">is</span> <span style="color: #007020">None</span> <span style="color: #000000; font-weight: bold">or</span> <span style="color: #007020">len</span>(rc<span style="color: #333333">.</span>sensor_readings) <span style="color: #333333">&lt;=</span> <span style="color: #0000DD; font-weight: bold">18</span>:
            asyncio<span style="color: #333333">.</span>run(asyncio<span style="color: #333333">.</span>sleep(<span style="color: #6600EE; font-weight: bold">0.05</span>))
        rc<span style="color: #333333">.</span>stop_recording()

        <span style="color: #888888"># Display the full sensor data</span>
        cols <span style="color: #333333">=</span> [
            <span style="background-color: #fff0f0">&quot;time&quot;</span>, <span style="background-color: #fff0f0">&quot;dist_r&quot;</span>, <span style="background-color: #fff0f0">&quot;dist_f&quot;</span>, <span style="background-color: #fff0f0">&quot;acc_x&quot;</span>, <span style="background-color: #fff0f0">&quot;acc_y&quot;</span>, <span style="background-color: #fff0f0">&quot;acc_z&quot;</span>, <span style="background-color: #fff0f0">&quot;gyr_x&quot;</span>,
            <span style="background-color: #fff0f0">&quot;gyr_y&quot;</span>, <span style="background-color: #fff0f0">&quot;gyr_z&quot;</span>, <span style="background-color: #fff0f0">&quot;mag_x&quot;</span>, <span style="background-color: #fff0f0">&quot;mag_y&quot;</span>, <span style="background-color: #fff0f0">&quot;mag_z&quot;</span>, <span style="background-color: #fff0f0">&quot;temp&quot;</span>
        ]
        sensor_data <span style="color: #333333">=</span> pd<span style="color: #333333">.</span>DataFrame(rc<span style="color: #333333">.</span>sensor_arr, columns<span style="color: #333333">=</span>cols)

        <span style="color: #888888"># We only really care about the front ToF data though:</span>
        sensor_ranges <span style="color: #333333">=</span> (np<span style="color: #333333">.</span>flip(sensor_data[<span style="background-color: #fff0f0">&quot;dist_f&quot;</span>][:<span style="color: #0000DD; font-weight: bold">18</span>]<span style="color: #333333">.</span>to_numpy()))[np<span style="color: #333333">.</span>newaxis]<span style="color: #333333">.</span>T

        <span style="color: #888888"># Convert millimeters to meters</span>
        sensor_ranges <span style="color: #333333">/=</span> <span style="color: #0000DD; font-weight: bold">1000</span>

        <span style="color: #008800; font-weight: bold">return</span> sensor_ranges, sensor_ranges  <span style="color: #888888"># We don&#39;t care about the second value</span>
        </pre></div>


        <h3>Localization:</h3>
        <p>
            This lab does not use the car's motors so odometry does not come into play. Therefore the prediction step is meaningless. I used exclusively the update step at each of four points to localize. This update step is identical to the one written in lab 11.
            Below are plots for the Belief given by the update step for each point:
        </p>
        <h5>
            The blue dots represent the belief and the green circle surrounds the location the car was placed.
        </h5>
        <h4>Point 1: (-3 ft, -2 ft, 0 deg)</h4>
        <img width="500" src="lab content/lab 12 content/neg3neg2.png">

        <h4>Point 2: (0 ft ,3 ft, 0 deg)</h4>
        <img width="500" src="lab content/lab 12 content/03.png">

        <h4>Point 3: (5 ft, -3 ft, 0 deg)</h4>
        <img width="500" src="lab content/lab 12 content/5neg3.png">

        <h4>Point 4: (5 ft, 3 ft, 0 deg)</h4>
        <img width="500" src="lab content/lab 12 content/53.png">

        <p>
            Orientation is not displayed in these plots but in each case it was near the correct value of zero degrees.
        </p>

        <h3>Conclusion:</h3>
        <p>
            In general localization was imperfect but came somewhat close. The exception is point 4, in which case localization was on the dot. The inaccuracies are likely due to error in the 20 degree rotations between observations and sensor noise.
        </p>

        <h3>Note:</h3>
        <footer>I worked with David Kim (jk2537) on this lab</footer>


    </section>

</body>

</html>